+++
date = '2025-06-20T10:22:11+08:00'
draft = false
title = 'mysql事务'
tags = ["数据库", "事务", "MySQL", "后端基础"]
+++

---
## 一、什么是事务
事务是指一组要么全部成功、要么全部失败的数据库操作单元，用于保证数据一致性。
常见场景：银行转账、订单支付、库存扣减等。

---
## 二、事务的四大特性（ACID）

### 1. 原子性（Atomicity）
一个事务中的操作要么全部成功，要么全部失败。

### 2. 一致性（Consistency）
事务执行前后，数据库必须从一个一致状态转到另一个一致状态。

### 3. 隔离性（Isolation）
多个事务并发执行时，彼此之间互不干扰。

### 4. 持久性（Durability）
事务一旦提交，数据将被永久保存，即使系统宕机也能恢复。

---
## 三、事务的隔离级别
| 隔离级别        | 脏读 | 不可重复读 | 幻读 |
|----------------|------|------------|------|
| 读未提交 Read Uncommitted | ✅   | ✅         | ✅   |
| 读已提交 Read Committed   | ❌   | ✅         | ✅   |
| 可重复读 Repeatable Read  | ❌   | ❌         | ✅（MySQL 用间隙锁部分解决幻读）|
| 串行化 Serializable     | ❌   | ❌         | ❌   |

mysql默认开启的是**可重复读**，使用MVCC控制

---
## 四、MVCC
**MVCC（Multi-Version Concurrency Control，多版本并发控制）**，是InnoDB实现读写不加锁、提升并发性能的关键机制。

核心目标是：让读不阻塞写，写也不阻塞读，提高数据库并发能力。

### 基本原理
对每行记录维护多个版本，控制事务只能读到自己能看到的版本，保证事务的隔离性。

InnoDB为每行记录维护两个隐藏列：trx_id(修改/新增该记录的事务id)，roll_pointer(指向undo_log记录)。
每行记录会对应一个undoLog，记录该条记录的历史版本，存储该版本的事务id以及原来的值。
通过readView来判断当前事务是否能读某个版本的记录，readView的结构如下：
|字段名 | 含义 |
|-------|---------|
|m_ids|当前生成视图时活跃事务 ID 列表（未提交的）|
|min_trx_id|m_ids 中最小事务 ID|
|max_trx_id|当前系统中下一个可用事务 ID（auto_increment）|
|creator_trx_id|当前事务的事务 ID（ReadView 的创建者）|
readView判断可见性的逻辑如下：
```
1. 拿到当前记录的版本号 trx_id
2. 根据当前事务的 ReadView 判断：
   - trx_id < min_trx_id   // 可见
   - trx_id ∈ m_ids        // 不可见
   - trx_id > max_trx_id   // 不可见
   - 其他                   // 可见
```
如此即可通过undoLog以及readView判断当前事务是否可以读某个版本，保证事务不会读到未提交的数据以及之后的事务。

#### 读已提交和可重复的的MVCC的差别
读已提交在每次查询操作时生成ReadView，可重复读在事务开始时生成一个ReadView。所以读已提交可以读到其他事务已提交的消息，导致不可重复读。

---
## 五、事务如何保证持久性
持久性指的是事务在提交之后记录就永久保存在磁盘，不会因为重启服务等丢失。mysql使用Redo Log保证事务的持久性。

### Redo Log是什么
Redo Log 是 物理日志，记录了对数据页的修改操作（比如某一页修改了哪一行、改成什么值）。
即使数据库宕机InnoDB可以用Redo Log重放操作，把数据恢复到最新提交状态。

Redo Log由以下两部分组成：
1. Log Buffer	内存中的重做日志缓冲区，事务提交前先写到这里
2. Log File 	磁盘上的日志文件，周期性或在提交时写入
事务提交前，所有的操作之后，先写入缓冲区，在事务提交时触发刷盘操作，刷盘成功才认为事务提交成功。即使数据库宕机，mysql也可以使用Redo Log重放保证持久性。
>假设事务 T 执行 “转账 100 元” 操作：
>
> T 开始执行，修改账户 A 和账户 B 的余额，相关 Redo Log 写入内存日志缓冲区；
>
> 事务提交时，Redo Log 从缓冲区刷入磁盘（WAL 协议）；
>
> 此时若系统崩溃，内存中未刷盘的数据页丢失，但 Redo Log 已持久化；
>
> 数据库重启时，通过 Redo Log 重做 T 的修改，将账户 A 和 B 的余额恢复到正确状态，确保持久性。