+++
date = '2025-06-19T16:21:14+08:00'
draft = false
title = 'Mysql_index'
tags = ['mysql']
categories = ['技术']
+++
## mysql索引
### 什么是索引
索引是一种数据结构，用于快速定位数据位置，类似于书籍的目录。在InnoDB引擎中，默认使用*B+树*实现索引，少数情况会使用*自适应哈希*索引。
### 为什么要使用B+树做索引
B+树是一种多叉树，其非叶子节点不存储数据，只存储子节点的索引，每个节点有多个子节点，叶子节点连接成一个双向链表，提高范围查询效率。
如果要探讨为什么使用B+树做索引，就需要比对其他数据结构，一般做索引有如下几种结构：
- B树: 同B+树一样，都是有序的多叉树，但是其非叶子节点会存储数据
- 哈希表: 哈希表可以快速定位到单条数据的地址，但是无法快速进行范围查询。

首先哈希表比较适合单条数据数据查询，而mysql经常会用到范围查询，所以哈希表对于B+树来说就比较劣势；其次B树由于非叶子节点会存储数据，导致范围查询时，需要进行中序遍历来获取范围数据，而B+树只需要遍历叶子节点的链表即可，所以在范围查询方面B+树的效率比B数更加稳定。
比较下来，B+树更适合应对mysql的查询条件。

### mysql索引的类型
#### 存储结构
从存储结构上分为聚簇索引与非聚簇索引。聚簇索引指的是索引上会存出整行数据，非聚簇索引存储主键id或者行的地址以及索引列的值。
> InnoDB的非聚簇索引存储主键的值，MyIsam存储行的物理地址。
#### 索引类型
从索引类型上分为主键索引、唯一索引、联合索引、一般索引、全文索引等。
##### 主键索引
聚簇索引，一般为自增主键
##### 唯一索引
非聚簇索引，不允许重复的索引，检索效率高
##### 联合索引
非聚簇索引，需要满足最左匹配原则
> 最左匹配原则：对a,b,c三个列组成联合索引，查询条件中需要按照声明索引的顺序增加查询条件，如`where a = xxx and b = xxx`可以走索引，但是`where b = xx and c = ccc`不会走索引，`where a = xxx and c = xxx`可以走索引，*但是只能走到a列的索引*，`WHERE a=1 AND b>10 AND c=3`走a和b的索引，范围查询之后会断链。抽象点来说就是需要有左边的列作为索引条件。
##### 一般索引
非聚簇索引，可以重复
##### 全文索引
支持自然语言搜索（MATCH AGAINST IN NATURAL LANGUAGE MODE）和布尔搜索（MATCH AGAINST IN BOOLEAN MODE）。一般用于文章和博客查询。
##### 哈希索引
InnoDB会自动为高频查询的索引页添加自适应哈希索引，仅支持 `=`  `IN` 条件查询
##### 前缀索引
对列的前缀进行索引，适用于长文本

### 索引设计原则
#### 避免过度索引
索引会增加存储空间占用，也会增加更新表时候的开销，因为要同步修改索引，所以索引并不是越多越好，仅在高频查询的字段上添加索引。
#### 联合索引注意顺序
经常查询、过滤性高（唯一值多）的字段应该放在联合索引的左侧
#### 索引尽量保持有序增长
B+树本身是个平衡树，所以插入一个有序的值只需要在最右侧添加一个节点，不会涉及到重排索引
#### 覆盖索引
前文已知mysql是非聚簇索引，所以当我们根据索引检索到字段之后，还需要根据主键id去主键索引里检索字段，会造成回表操作，导致效率降低。为了避免这种情况，我们可以对经常查询的字段添加联合索引，查询字段时尽量避免`select * `，而是改用具体的字段，这样索引中已经包含了要检索的字段之后，就不会再去主键索引中检索。

### 索引失效场景
#### 不符合最左匹配原则
当联合索引的查询不符合最左匹配原则时会导致索引失效，需要修改索引或者查询语句
#### in条件中元素过多
in条件过多之后，mysql优化器可能会认为全表扫描更适合，导致索引失效
#### or条件前后存在非索引字段
如果使用or条件查询，or前后存在有非索引字段会导致索引失效，因为也需要根据另一个条件进行筛选。
#### 使用模糊查询，占位符在前面
当使用`like %aasdas`时，由于没有办法去匹配索引的值是否匹配，会导致索引失效，走全表扫描
#### 对索引字段采用函数计算时
对字段使用函数会导致索引失效。
#### 数据类型隐式转换
如果对String类型查询但是传入的条件是数字类型，就会触发隐式转化，导致索引失效。
```
-- 假设 phone 是字符串索引
SELECT * FROM user WHERE phone = 13800138000; -- 失效（数字转字符串）
```
#### !=或者not in多数条件下无法走索引
索引本质上是根据条件去筛选，这种不等于或者不在集合里没办法精准定位到某些叶子节点。

### 索引下推
索引下推指的是mysql在存储引擎层根据索引字段进行筛选之后返回给server层，减少返回的数据量。可以通过`explain`观察extra字段是否有`Using index condition`，如果有就是开启了索引下推。

#### 索引下推的优势
假设我们对表a,b字段组成联合索引，并且执行以下sql
```
SELECT * FROM table WHERE a = 1 AND b LIKE '%abc%';
```
当没有开启索引下推，执行流程如下
1. 存储引擎筛选`a=1`的索引
2. 回表拿到所有`a=1`的记录
3. server层对 `b LIKE '%abc%'`  进行S筛选
当开启索引下推之后：
1. 存储引擎筛选`a=1`的索引
2. 筛选`b LIKE '%abc%'`的索引
3. 回表查询
4. server层后续操作
可以看到，索引下推可以大幅减少回表数量，提高查询效率。

#### 触发条件
1. 没有触发覆盖索引
2. where条件触发索引列的筛选条件
3. 仅适用于二级索引